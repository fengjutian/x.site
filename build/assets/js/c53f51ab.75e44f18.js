"use strict";(self.webpackChunkx_site=self.webpackChunkx_site||[]).push([[8215],{3732:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var t=n(4848),s=n(8453);const o={sidebar_position:1},a="Errors",i={id:"actix/advanced/Errors",title:"Errors",description:"Actix Web uses its own actixweb::ResponseError trait for error handling from web handlers.",source:"@site/docs/actix/advanced/Errors.md",sourceDirName:"actix/advanced",slug:"/actix/advanced/Errors",permalink:"/x.site/docs/actix/advanced/Errors",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/actix/advanced/Errors.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"actixSidebar",previous:{title:"\u8fdb\u9636",permalink:"/x.site/docs/category/\u8fdb\u9636"},next:{title:"URL Dispatch",permalink:"/x.site/docs/actix/advanced/URL-Dispatch"}},d={},l=[];function c(e){const r={code:"code",h1:"h1",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{id:"errors",children:"Errors"}),"\n",(0,t.jsxs)(r.p,{children:["Actix Web uses its own ",(0,t.jsx)(r.code,{children:"actix_web::error::Error"})," type and ",(0,t.jsx)(r.code,{children:"actix_web::error::ResponseError"})," trait for error handling from web handlers."]}),"\n",(0,t.jsxs)(r.p,{children:["If a handler returns an Error (referring to the general Rust trait ",(0,t.jsx)(r.code,{children:"std::error::Error"}),") in a Result that also implements the ResponseError trait, Actix Web will render that error as an HTTP response with its corresponding ",(0,t.jsx)(r.code,{children:"actix_web::http::StatusCode"}),". An internal server error is generated by default:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"pub trait ResponseError {\n    fn error_response(&self) -> HttpResponse<BoxBody>;\n    fn status_code(&self) -> StatusCode;\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"A Responder coerces compatible Results into HTTP responses:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"impl<T: Responder, E: Into<Error>> Responder for Result<T, E>\n"})}),"\n",(0,t.jsx)(r.p,{children:"Error in the code above is actix-web's error definition, and any errors that implement ResponseError can be converted to one automatically."}),"\n",(0,t.jsxs)(r.p,{children:["Actix Web provides ResponseError implementations for some common non-actix errors. For example, if a handler responds with an ",(0,t.jsx)(r.code,{children:"io::Error"}),", that error is converted into an HttpInternalServerError:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use std::io;\nuse actix_files::NamedFile;\n\nfn index(_req: HttpRequest) -> io::Result<NamedFile> {\n    Ok(NamedFile::open("static/index.html")?)\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"See the Actix Web API documentation for a full list of foreign implementations for ResponseError."}),"\n",(0,t.jsx)(r.h1,{id:"an-example-of-a-custom-error-response",children:"An example of a custom error response"}),"\n",(0,t.jsx)(r.p,{children:"Here's an example implementation for ResponseError, using the derive_more crate for declarative error enums."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use actix_web::{error, Result};\nuse derive_more::{Display, Error};\n\n#[derive(Debug, Display, Error)]\n#[display(fmt = "my error: {}", name)]\nstruct MyError {\n    name: &\'static str,\n}\n\n// Use default implementation for `error_response()` method\nimpl error::ResponseError for MyError {}\n\nasync fn index() -> Result<&\'static str, MyError> {\n    Err(MyError { name: "test" })\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["ResponseError has a default implementation for ",(0,t.jsx)(r.code,{children:"error_response()"})," that will render a 500 (internal server error), and that's what will happen when the index handler executes above."]}),"\n",(0,t.jsxs)(r.p,{children:["Override ",(0,t.jsx)(r.code,{children:"error_response()"})," to produce more useful results:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use actix_web::{\n    error, get,\n    http::{header::ContentType, StatusCode},\n    App, HttpResponse,\n};\nuse derive_more::{Display, Error};\n\n#[derive(Debug, Display, Error)]\nenum MyError {\n    #[display(fmt = "internal error")]\n    InternalError,\n\n    #[display(fmt = "bad request")]\n    BadClientData,\n\n    #[display(fmt = "timeout")]\n    Timeout,\n}\n\nimpl error::ResponseError for MyError {\n    fn error_response(&self) -> HttpResponse {\n        HttpResponse::build(self.status_code())\n            .insert_header(ContentType::html())\n            .body(self.to_string())\n    }\n\n    fn status_code(&self) -> StatusCode {\n        match *self {\n            MyError::InternalError => StatusCode::INTERNAL_SERVER_ERROR,\n            MyError::BadClientData => StatusCode::BAD_REQUEST,\n            MyError::Timeout => StatusCode::GATEWAY_TIMEOUT,\n        }\n    }\n}\n\n#[get("/")]\nasync fn index() -> Result<&\'static str, MyError> {\n    Err(MyError::BadClientData)\n}\n'})}),"\n",(0,t.jsx)(r.h1,{id:"error-helpers",children:"Error helpers"}),"\n",(0,t.jsx)(r.p,{children:"Actix Web provides a set of error helper functions that are useful for generating specific HTTP error codes from other errors. Here we convert MyError, which doesn't implement the ResponseError trait, to a 400 (bad request) using map_err:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use actix_web::{error, get, App, HttpServer};\n\n#[derive(Debug)]\nstruct MyError {\n    name: &\'static str,\n}\n\n#[get("/")]\nasync fn index() -> actix_web::Result<String> {\n    let result = Err(MyError { name: "test error" });\n\n    result.map_err(|err| error::ErrorBadRequest(err.name))\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"See the API documentation for actix-web's error module for a full list of available error helpers."}),"\n",(0,t.jsx)(r.h1,{id:"error-logging",children:"Error logging"}),"\n",(0,t.jsxs)(r.p,{children:["Actix logs all errors at the ",(0,t.jsx)(r.code,{children:"WARN"})," log level. If an application's log level is set to ",(0,t.jsx)(r.code,{children:"DEBUG"})," and ",(0,t.jsx)(r.code,{children:"RUST_BACKTRACE"})," is enabled, the backtrace is also logged. These are configurable with environmental variables:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-xml",children:">> RUST_BACKTRACE=1 RUST_LOG=actix_web=debug cargo run\n"})}),"\n",(0,t.jsx)(r.p,{children:"The Error type uses the cause's error backtrace if available. If the underlying failure does not provide a backtrace, a new backtrace is constructed pointing to the point where the conversion occurred (rather than the origin of the error)."}),"\n",(0,t.jsx)(r.h1,{id:"recommended-practices-in-error-handling",children:"Recommended practices in error handling"}),"\n",(0,t.jsx)(r.p,{children:"It might be useful to think about dividing the errors an application produces into two broad groups: those which are intended to be user-facing, and those which are not."}),"\n",(0,t.jsxs)(r.p,{children:["An example of the former is that I might use failure to specify a ",(0,t.jsx)(r.code,{children:"UserError"})," enum which encapsulates a ",(0,t.jsx)(r.code,{children:"ValidationError"})," to return whenever a user sends bad input:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use actix_web::{\n    error, get,\n    http::{header::ContentType, StatusCode},\n    App, HttpResponse, HttpServer,\n};\nuse derive_more::{Display, Error};\n\n#[derive(Debug, Display, Error)]\nenum UserError {\n    #[display(fmt = "Validation error on field: {}", field)]\n    ValidationError { field: String },\n}\n\nimpl error::ResponseError for UserError {\n    fn error_response(&self) -> HttpResponse {\n        HttpResponse::build(self.status_code())\n            .insert_header(ContentType::html())\n            .body(self.to_string())\n    }\n    fn status_code(&self) -> StatusCode {\n        match *self {\n            UserError::ValidationError { .. } => StatusCode::BAD_REQUEST,\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"This will behave exactly as intended because the error message defined with display is written with the explicit intent to be read by a user."}),"\n",(0,t.jsx)(r.p,{children:"However, sending back an error's message isn't desirable for all errors -- there are many failures that occur in a server environment where we'd probably want the specifics to be hidden from the user. For example, if a database goes down and client libraries start producing connect timeout errors, or if an HTML template was improperly formatted and errors when rendered. In these cases, it might be preferable to map the errors to a generic error suitable for user consumption."}),"\n",(0,t.jsx)(r.p,{children:"Here's an example that maps an internal error to a user-facing InternalError with a custom message:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'vuse actix_web::{\n    error, get,\n    http::{header::ContentType, StatusCode},\n    App, HttpResponse, HttpServer,\n};\nuse derive_more::{Display, Error};\n\n#[derive(Debug, Display, Error)]\nenum UserError {\n    #[display(fmt = "An internal error occurred. Please try again later.")]\n    InternalError,\n}\n\nimpl error::ResponseError for UserError {\n    fn error_response(&self) -> HttpResponse {\n        HttpResponse::build(self.status_code())\n            .insert_header(ContentType::html())\n            .body(self.to_string())\n    }\n\n    fn status_code(&self) -> StatusCode {\n        match *self {\n            UserError::InternalError => StatusCode::INTERNAL_SERVER_ERROR,\n        }\n    }\n}\n\n#[get("/")]\nasync fn index() -> Result<&\'static str, UserError> {\n    do_thing_that_fails().map_err(|_e| UserError::InternalError)?;\n    Ok("success!")\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"By dividing errors into those which are user facing and those which are not, we can ensure that we don't accidentally expose users to errors thrown by application internals which they weren't meant to see."}),"\n",(0,t.jsx)(r.h1,{id:"error-logging-1",children:"Error Logging"}),"\n",(0,t.jsxs)(r.p,{children:["This is a basic example using ",(0,t.jsx)(r.code,{children:"middleware::Logger"})," which depends on ",(0,t.jsx)(r.code,{children:"env_logger"})," and log:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-xml",children:'[dependencies]\nenv_logger = "0.8"\nlog = "0.4"\n'})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use actix_web::{error, get, middleware::Logger, App, HttpServer, Result};\nuse derive_more::{Display, Error};\nuse log::info;\n\n#[derive(Debug, Display, Error)]\n#[display(fmt = "my error: {}", name)]\npub struct MyError {\n    name: &\'static str,\n}\n\n// Use default implementation for `error_response()` method\nimpl error::ResponseError for MyError {}\n\n#[get("/")]\nasync fn index() -> Result<&\'static str, MyError> {\n    let err = MyError { name: "test error" };\n    info!("{}", err);\n    Err(err)\n}\n\n#[rustfmt::skip]\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    std::env::set_var("RUST_LOG", "info");\n    std::env::set_var("RUST_BACKTRACE", "1");\n    env_logger::init();\n\n    HttpServer::new(|| {\n        let logger = Logger::default();\n\n        App::new()\n            .wrap(logger)\n            .service(index)\n    })\n    .bind(("127.0.0.1", 8080))?\n    .run()\n    .await\n}\n'})})]})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>i});var t=n(6540);const s={},o=t.createContext(s);function a(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);