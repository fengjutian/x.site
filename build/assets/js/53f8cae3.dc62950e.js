"use strict";(self.webpackChunkx_site=self.webpackChunkx_site||[]).push([[8481],{4741:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var t=s(5893),r=s(1151);const i={sidebar_position:4},o="Server",a={id:"actix/basics/Server",title:"Server",description:"HTTP Server",source:"@site/docs/actix/basics/Server.md",sourceDirName:"actix/basics",slug:"/actix/basics/Server",permalink:"/x.site/docs/actix/basics/Server",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/actix/basics/Server.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"actixSidebar",previous:{title:"Application",permalink:"/x.site/docs/actix/basics/Application"},next:{title:"Extraction",permalink:"/x.site/docs/actix/basics/Extraction"}},c={},l=[{value:"HTTP Server",id:"http-server",level:2},{value:"\u591a\u7ebf\u7a0b",id:"\u591a\u7ebf\u7a0b",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"server",children:"Server"}),"\n",(0,t.jsx)(n.h2,{id:"http-server",children:"HTTP Server"}),"\n",(0,t.jsx)(n.p,{children:"The HttpServer type is responsible for serving HTTP requests."}),"\n",(0,t.jsx)(n.p,{children:"HttpServer accepts an application factory as a parameter, and the application factory must have Send + Sync boundaries. More about that in the multi-threading section."}),"\n",(0,t.jsx)(n.p,{children:'To start the web server it must first be bound to a network socket. Use HttpServer::bind() with a socket address tuple or string such as ("127.0.0.1", 8080) or "0.0.0.0:8080". This will fail if the socket is being used by another application.'}),"\n",(0,t.jsx)(n.p,{children:"After the bind is successful, use HttpServer::run() to return a Server instance. The Server must be awaited or spawned to start processing requests and will run until it receives a shutdown signal (such as, by default, a ctrl-c; read more here)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use actix_web::{web, App, HttpResponse, HttpServer};\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| App::new().route("/", web::get().to(HttpResponse::Ok)))\n        .bind(("127.0.0.1", 8080))?\n        .run()\n        .await\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"\u591a\u7ebf\u7a0b",children:"\u591a\u7ebf\u7a0b"}),"\n",(0,t.jsx)(n.p,{children:"HttpServer automatically starts a number of HTTP workers, by default this number is equal to the number of physical CPUs in the system. This number can be overridden with the HttpServer::workers() method."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use actix_web::{web, App, HttpResponse, HttpServer};\n\n#[actix_web::main]\nasync fn main() {\n    HttpServer::new(|| App::new().route("/", web::get().to(HttpResponse::Ok))).workers(4);\n    // <- Start 4 workers\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Once the workers are created, they each receive a separate application instance to handle requests. Application state is not shared between the threads, and handlers are free to manipulate their copy of the state with no concurrency concerns."}),"\n",(0,t.jsx)(n.p,{children:"Application state does not need to be Send or Sync, but application factories must be Send + Sync."}),"\n",(0,t.jsx)(n.p,{children:"To share state between worker threads, use an Arc/Data. Special care should be taken once sharing and synchronization are introduced. In many cases, performance costs are inadvertently introduced as a result of locking the shared state for modifications."}),"\n",(0,t.jsx)(n.p,{children:"In some cases these costs can be alleviated using more efficient locking strategies, for example using read/write locks instead of mutexes to achieve non-exclusive locking, but the most performant implementations often tend to be ones in which no locking occurs at all."}),"\n",(0,t.jsx)(n.p,{children:"Since each worker thread processes its requests sequentially, handlers which block the current thread will cause the current worker to stop processing new requests:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn my_handler() -> impl Responder {\n    std::thread::sleep(Duration::from_secs(5)); // <-- Bad practice! Will cause the current worker thread to hang!\n    "response"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"For this reason, any long, non-cpu-bound operation (e.g. I/O, database operations, etc.) should be expressed as futures or asynchronous functions. Async handlers get executed concurrently by worker threads and thus don't block execution:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'async fn my_handler() -> impl Responder {\n    tokio::time::sleep(Duration::from_secs(5)).await; // <-- Ok. Worker thread will handle other requests here\n    "response"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"The same limitation applies to extractors as well. When a handler function receives an argument which implements FromRequest, and that implementation blocks the current thread, the worker thread will block when running the handler. Special attention must be given when implementing extractors for this very reason, and they should also be implemented asynchronously where needed."}),"\n",(0,t.jsx)(n.h1,{id:"tls--https",children:"TLS / HTTPS"}),"\n",(0,t.jsxs)(n.p,{children:["Actix Web supports two TLS implementations out-of-the-box: ",(0,t.jsx)(n.code,{children:"rustls"})," and ",(0,t.jsx)(n.code,{children:"openssl"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"rustls"})," crate feature is for ",(0,t.jsx)(n.code,{children:"rustls"})," integration and ",(0,t.jsx)(n.code,{children:"openssl"})," is for ",(0,t.jsx)(n.code,{children:"openssl"})," integration."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'[dependencies]\nactix-web = { version = "4", features = ["openssl"] }\nopenssl = { version = "0.10" }\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use actix_web::{get, App, HttpRequest, HttpServer, Responder};\nuse openssl::ssl::{SslAcceptor, SslFiletype, SslMethod};\n\n#[get("/")]\nasync fn index(_req: HttpRequest) -> impl Responder {\n    "Welcome!"\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    // load TLS keys\n    // to create a self-signed temporary cert for testing:\n    // `openssl req -x509 -newkey rsa:4096 -nodes -keyout key.pem -out cert.pem -days 365 -subj \'/CN=localhost\'`\n    let mut builder = SslAcceptor::mozilla_intermediate(SslMethod::tls()).unwrap();\n    builder\n        .set_private_key_file("key.pem", SslFiletype::PEM)\n        .unwrap();\n    builder.set_certificate_chain_file("cert.pem").unwrap();\n\n    HttpServer::new(|| App::new().service(index))\n        .bind_openssl("127.0.0.1:8080", builder)?\n        .run()\n        .await\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"To create the key.pem and cert.pem use the command. Fill in your own subject"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'$ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem \\\n  -days 365 -sha256 -subj "/C=CN/ST=Fujian/L=Xiamen/O=TVlinux/OU=Org/CN=muro.lxd"\n'})}),"\n",(0,t.jsx)(n.p,{children:"To remove the password, then copy nopass.pem to key.pem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"$ openssl rsa -in key.pem -out nopass.pem\n"})}),"\n",(0,t.jsx)(n.h1,{id:"keep-alive",children:"Keep-Alive"}),"\n",(0,t.jsx)(n.p,{children:"Actix Web keeps connections open to wait for subsequent requests."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Duration::from_secs(75)"})," or ",(0,t.jsx)(n.code,{children:"KeepAlive::Timeout(75)"}),": enables 75 second keep-alive timer."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"KeepAlive::Os"}),": uses OS keep-alive."]}),"\n",(0,t.jsxs)(n.li,{children:["None or ",(0,t.jsx)(n.code,{children:"KeepAlive::Disabled"}),": disables keep-alive."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use actix_web::{http::KeepAlive, HttpServer};\nuse std::time::Duration;\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    // Set keep-alive to 75 seconds\n    let _one = HttpServer::new(app).keep_alive(Duration::from_secs(75));\n\n    // Use OS's keep-alive (usually quite long)\n    let _two = HttpServer::new(app).keep_alive(KeepAlive::Os);\n\n    // Disable keep-alive\n    let _three = HttpServer::new(app).keep_alive(None);\n\n    Ok(())\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If the first option above is selected, then keep-alive is enabled for HTTP/1.1 requests if the response does not explicitly disallow it by, for example, setting the connection type to ",(0,t.jsx)(n.code,{children:"Close"})," or ",(0,t.jsx)(n.code,{children:"Upgrade"}),". Force closing a connection can be done with the ",(0,t.jsx)(n.code,{children:"force_close()"})," method on ",(0,t.jsx)(n.code,{children:"HttpResponseBuilder"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use actix_web::{http, HttpRequest, HttpResponse};\n\nasync fn index(_req: HttpRequest) -> HttpResponse {\n    let mut resp = HttpResponse::Ok()\n        .force_close() // <- Close connection on HttpResponseBuilder\n        .finish();\n\n    // Alternatively close connection on the HttpResponse struct\n    resp.head_mut().set_connection_type(http::ConnectionType::Close);\n\n    resp\n}\n"})}),"\n",(0,t.jsx)(n.h1,{id:"graceful-shutdown",children:"Graceful shutdown"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"HttpServer"})," supports graceful shutdown. After receiving a stop signal, workers have a specific amount of time to finish serving requests. Any workers still alive after the timeout are force-dropped. By default the shutdown timeout is set to 30 seconds. You can change this parameter with the ",(0,t.jsx)(n.code,{children:"HttpServer::shutdown_timeout()"})," method."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"HttpServer"})," handles several OS signals. CTRL-C is available on all OSes, other signals are available on unix systems."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"SIGINT - Force shutdown workers"}),"\n",(0,t.jsx)(n.li,{children:"SIGTERM - Graceful shutdown workers"}),"\n",(0,t.jsx)(n.li,{children:"SIGQUIT - Force shutdown workers"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>a,a:()=>o});var t=s(7294);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);