"use strict";(self.webpackChunkx_site=self.webpackChunkx_site||[]).push([[4350],{8269:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var s=n(5893),r=n(1151);const a={sidebar_position:2},o="\u5f00\u59cb",i={id:"actix/basics/GettingStared",title:"\u5f00\u59cb",description:"\u5b89\u88c5 Rust",source:"@site/docs/actix/basics/GettingStared.md",sourceDirName:"actix/basics",slug:"/actix/basics/GettingStared",permalink:"/x.site/docs/actix/basics/GettingStared",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/actix/basics/GettingStared.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"actixSidebar",previous:{title:"\u57fa\u7840",permalink:"/x.site/docs/category/\u57fa\u7840"},next:{title:"Application",permalink:"/x.site/docs/actix/basics/Application"}},c={},d=[{value:"\u5b89\u88c5 Rust",id:"\u5b89\u88c5-rust",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"\u5f00\u59cb",children:"\u5f00\u59cb"}),"\n",(0,s.jsx)(t.h2,{id:"\u5b89\u88c5-rust",children:"\u5b89\u88c5 Rust"}),"\n",(0,s.jsxs)(t.p,{children:["If you don't have Rust yet, we recommend you use ",(0,s.jsx)(t.code,{children:"rustup"})," to manage your Rust installation. ",(0,s.jsx)(t.a,{href:"https://doc.rust-lang.org/book/ch01-01-installation.html",children:"The official rust guide"})," has a wonderful section on getting started."]}),"\n",(0,s.jsxs)(t.p,{children:["Actix Web currently has a minimum supported Rust version (MSRV) of 1.59. Running ",(0,s.jsx)(t.code,{children:"rustup update"})," will ensure you have the latest and greatest Rust version available. As such, this guide assumes you are running Rust 1.59 or later."]}),"\n",(0,s.jsx)(t.h1,{id:"hello-world",children:"Hello, world!"}),"\n",(0,s.jsx)(t.p,{children:"Start by creating a new binary-based Cargo project and changing into the new directory:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-xml",children:"cargo new hello-world\ncd hello-world\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Add ",(0,s.jsx)(t.code,{children:"actix-web"})," as a dependency of your project by adding the following to your Cargo.toml file."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-xml",children:'[dependencies]\nactix-web = "4"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Request handlers use async functions that accept zero or more parameters. These parameters can be extracted from a request (see ",(0,s.jsx)(t.code,{children:"FromRequest"})," trait) and returns a type that can be converted into an ",(0,s.jsx)(t.code,{children:"HttpResponse"})," (see ",(0,s.jsx)(t.code,{children:"Responder"})," trait):"]}),"\n",(0,s.jsxs)(t.p,{children:["Replace the contents of ",(0,s.jsx)(t.code,{children:"src/main.rs"})," with the following:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'use actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder};\n\n#[get("/")]\nasync fn hello() -> impl Responder {\n    HttpResponse::Ok().body("Hello world!")\n}\n\n#[post("/echo")]\nasync fn echo(req_body: String) -> impl Responder {\n    HttpResponse::Ok().body(req_body)\n}\n\nasync fn manual_hello() -> impl Responder {\n    HttpResponse::Ok().body("Hey there!")\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Notice that some of these handlers have routing information attached directly using the built-in macros. These allow you to specify the method and path that the handler should respond to. You will see below how to register manual_hello (i.e. routes that do not use a routing macro)."}),"\n",(0,s.jsx)(t.p,{children:'Next, create an App instance and register the request handlers. Use App::service for the handlers using routing macros and App::route for manually routed handlers, declaring the path and method. Finally, the app is started inside an HttpServer which will serve incoming requests using your App as an "application factory".'}),"\n",(0,s.jsx)(t.p,{children:"Further append the following main function to src/main.rs:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .service(hello)\n            .service(echo)\n            .route("/hey", web::get().to(manual_hello))\n    })\n    .bind(("127.0.0.1", 8080))?\n    .run()\n    .await\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["That's it! Compile and run the program with cargo run. The #[actix_web::main] macro executes the async main function within the actix runtime. Now you can go to ",(0,s.jsx)(t.a,{href:"http://127.0.0.1:8080/",children:"http://127.0.0.1:8080/"})," or any of the other routes you defined to see the results."]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>o});var s=n(7294);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);