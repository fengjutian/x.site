"use strict";(self.webpackChunkx_site=self.webpackChunkx_site||[]).push([[3147],{9057:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>l,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var s=n(5893),a=n(1151);const i={sidebar_position:3},r="Application",c={id:"actix/basics/Application",title:"Application",description:"activx-web\u63d0\u4f9b\u4e86\u5404\u79cd\u539f\u8bed\u6765\u4f7f\u7528Rust\u6784\u5efaweb\u670d\u52a1\u5668\u548c\u5e94\u7528\u7a0b\u5e8f\u3002\u5b83\u63d0\u4f9b\u8def\u7531\u3001\u4e2d\u95f4\u4ef6\u3001\u8bf7\u6c42\u7684\u9884\u5904\u7406\u3001\u54cd\u5e94\u7684\u540e\u5904\u7406\u7b49\u3002",source:"@site/docs/actix/basics/Application.md",sourceDirName:"actix/basics",slug:"/actix/basics/Application",permalink:"/x.site/docs/actix/basics/Application",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/actix/basics/Application.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"actixSidebar",previous:{title:"\u5f00\u59cb",permalink:"/x.site/docs/actix/basics/GettingStared"},next:{title:"Server",permalink:"/x.site/docs/actix/basics/Server"}},o={},p=[];function d(e){const t={code:"code",h1:"h1",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"application",children:"Application"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"activx-web"}),"\u63d0\u4f9b\u4e86\u5404\u79cd\u539f\u8bed\u6765\u4f7f\u7528Rust\u6784\u5efaweb\u670d\u52a1\u5668\u548c\u5e94\u7528\u7a0b\u5e8f\u3002\u5b83\u63d0\u4f9b\u8def\u7531\u3001\u4e2d\u95f4\u4ef6\u3001\u8bf7\u6c42\u7684\u9884\u5904\u7406\u3001\u54cd\u5e94\u7684\u540e\u5904\u7406\u7b49\u3002"]}),"\n",(0,s.jsxs)(t.p,{children:["\u6240\u6709",(0,s.jsx)(t.code,{children:"activx-web"}),"\u670d\u52a1\u5668\u90fd\u662f\u56f4\u7ed5\u5e94\u7528\u7a0b\u5e8f\u5b9e\u4f8b\u6784\u5efa\u7684\u3002\u5b83\u7528\u4e8e\u6ce8\u518c\u8d44\u6e90\u548c\u4e2d\u95f4\u4ef6\u7684\u8def\u7531\u3002\u5b83\u8fd8\u5b58\u50a8\u5728\u540c\u4e00\u8303\u56f4\u5185\u7684\u6240\u6709\u5904\u7406\u7a0b\u5e8f\u4e4b\u95f4\u5171\u4eab\u7684\u5e94\u7528\u7a0b\u5e8f\u72b6\u6001\u3002"]}),"\n",(0,s.jsx)(t.p,{children:"\u5e94\u7528\u7a0b\u5e8f\u7684\u4f5c\u7528\u57df\u5145\u5f53\u6240\u6709\u8def\u7531\u7684\u547d\u540d\u7a7a\u95f4\uff0c\u5373\u7279\u5b9a\u5e94\u7528\u7a0b\u5e8f\u4f5c\u7528\u57df\u7684\u6240\u6709\u8def\u7531\u90fd\u5177\u6709\u76f8\u540c\u7684url\u8def\u5f84\u524d\u7f00\u3002\u5e94\u7528\u7a0b\u5e8f\u524d\u7f00\u603b\u662f\u5305\u542b\u4e00\u4e2a\u524d\u5bfc\u7684\u201c/\u201d\u659c\u7ebf\u3002\u5982\u679c\u63d0\u4f9b\u7684\u524d\u7f00\u4e0d\u5305\u542b\u524d\u5bfc\u659c\u6760\uff0c\u5219\u4f1a\u81ea\u52a8\u63d2\u5165\u3002\u524d\u7f00\u5e94\u7531\u503c\u8def\u5f84\u6bb5\u7ec4\u6210\u3002"}),"\n",(0,s.jsxs)(t.p,{children:["\u5bf9\u4e8e\u5177\u6709",(0,s.jsx)(t.code,{children:"scope/app"}),"\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u4efb\u4f55\u5177\u6709\u8def\u5f84",(0,s.jsx)(t.code,{children:"/app"}),"\u3001",(0,s.jsx)(t.code,{children:"/app/"}),"\u6216",(0,s.jsx)(t.code,{children:"/app/test"}),"\u7684\u8bf7\u6c42\u90fd\u5c06\u5339\u914d\uff1b\u4f46\u662f\uff0c\u8def\u5f84/\u5e94\u7528\u7a0b\u5e8f\u5c06\u4e0d\u5339\u914d\u3002"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'use actix_web::{web, App, HttpServer, Responder};\n\nasync fn index() -> impl Responder {\n    "Hello world!"\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new().service(\n            // prefixes all resources and routes attached to it...\n            web::scope("/app")\n                // ...so this handles requests for `GET /app/index.html`\n                .route("/index.html", web::get().to(index)),\n        )\n    })\n    .bind(("127.0.0.1", 8080))?\n    .run()\n    .await\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"In this example, an application with the /app prefix and an index.html resource is created. This resource is available through the /app/index.html url."}),"\n",(0,s.jsx)(t.h1,{id:"state",children:"State"}),"\n",(0,s.jsxs)(t.p,{children:["Application state is shared with all routes and resources within the same scope. State can be accessed with the ",(0,s.jsx)(t.code,{children:"web::Data<T>"})," extractor where T is the type of the state. State is also accessible for middleware."]}),"\n",(0,s.jsx)(t.p,{children:"Let's write a simple application and store the application name in the state:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'use actix_web::{get, web, App, HttpServer};\n\n// This struct represents state\nstruct AppState {\n    app_name: String,\n}\n\n#[get("/")]\nasync fn index(data: web::Data<AppState>) -> String {\n    let app_name = &data.app_name; // <- get app_name\n    format!("Hello {app_name}!") // <- response with app_name\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Next, pass in the state when initializing the App and start the application:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .app_data(web::Data::new(AppState {\n                app_name: String::from("Actix Web"),\n            }))\n            .service(index)\n    })\n    .bind(("127.0.0.1", 8080))?\n    .run()\n    .await\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Any number of state types could be registered within the application."}),"\n",(0,s.jsx)(t.h1,{id:"shared-mutable-state",children:"Shared Mutable State"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"HttpServer"})," accepts an application factory rather than an application instance. An ",(0,s.jsx)(t.code,{children:"HttpServer"})," constructs an application instance for each thread. Therefore, application data must be constructed multiple times. If you want to share data between different threads, a shareable object should be used, e.g. ",(0,s.jsx)(t.code,{children:"Send + Sync"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Internally, ",(0,s.jsx)(t.code,{children:"web::Data"})," uses ",(0,s.jsx)(t.code,{children:"Arc"}),". So in order to avoid creating two ",(0,s.jsx)(t.code,{children:"Arcs"}),", we should create our Data before registering it using ",(0,s.jsx)(t.code,{children:"App::app_data()"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"In the following example, we will write an application with mutable, shared state. First, we define our state and create our handler:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'use actix_web::{web, App, HttpServer};\nuse std::sync::Mutex;\n\nstruct AppStateWithCounter {\n    counter: Mutex<i32>, // <- Mutex is necessary to mutate safely across threads\n}\n\nasync fn index(data: web::Data<AppStateWithCounter>) -> String {\n    let mut counter = data.counter.lock().unwrap(); // <- get counter\'s MutexGuard\n    *counter += 1; // <- access counter inside MutexGuard\n\n    format!("Request number: {counter}") // <- response with count\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["and register the data in an ",(0,s.jsx)(t.code,{children:"App"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    // Note: web::Data created _outside_ HttpServer::new closure\n    let counter = web::Data::new(AppStateWithCounter {\n        counter: Mutex::new(0),\n    });\n\n    HttpServer::new(move || {\n        // move counter into the closure\n        App::new()\n            .app_data(counter.clone()) // <- register the created data\n            .route("/", web::get().to(index))\n    })\n    .bind(("127.0.0.1", 8080))?\n    .run()\n    .await\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Key takeaways:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["State initialized inside the closure passed to ",(0,s.jsx)(t.code,{children:"HttpServer::new"})," is local to the worker thread and may become de-synced if modified."]}),"\n",(0,s.jsxs)(t.li,{children:["To achieve globally shared state, it must be created outside of the closure passed to ",(0,s.jsx)(t.code,{children:"HttpServer::new"})," and ",(0,s.jsx)(t.code,{children:"moved/cloned"})," in."]}),"\n"]}),"\n",(0,s.jsx)(t.h1,{id:"using-an-application-scope-to-compose-applications",children:"Using an Application Scope to Compose Applications"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"web::scope()"})," method allows setting a resource group prefix. This scope represents a resource prefix that will be prepended to all resource patterns added by the resource configuration. This can be used to help mount a set of routes at a different location than the original author intended while still maintaining the same resource names."]}),"\n",(0,s.jsx)(t.p,{children:"For example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[actix_web::main]\nasync fn main() {\n    let scope = web::scope("/users").service(show_users);\n    App::new().service(scope);\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["In the above example, the show_users route will have an effective route pattern of ",(0,s.jsx)(t.code,{children:"/users/show"})," instead of ",(0,s.jsx)(t.code,{children:"/show"})," because the application's scope argument will be prepended to the pattern. The route will then only match if the URL path is ",(0,s.jsx)(t.code,{children:"/users/show"}),", and when the ",(0,s.jsx)(t.code,{children:"HttpRequest.url_for()"})," function is called with the route name show_users, it will generate a URL with that same path."]}),"\n",(0,s.jsx)(t.h1,{id:"application-guards-and-virtual-hosting",children:"Application guards and virtual hosting"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"web::scope()"})," method allows setting a resource group prefix. This scope represents a resource prefix that will be prepended to all resource patterns added by the resource configuration. This can be used to help mount a set of routes at a different location than the original author intended while still maintaining the same resource names."]}),"\n",(0,s.jsx)(t.p,{children:"For example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[actix_web::main]\nasync fn main() {\n    let scope = web::scope("/users").service(show_users);\n    App::new().service(scope);\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["In the above example, the show_users route will have an effective route pattern of ",(0,s.jsx)(t.code,{children:"/users/show"})," instead of ",(0,s.jsx)(t.code,{children:"/show"})," because the application's scope argument will be prepended to the pattern. The route will then only match if the URL path is ",(0,s.jsx)(t.code,{children:"/users/show"}),", and when the ",(0,s.jsx)(t.code,{children:"HttpRequest.url_for()"})," function is called with the route name show_users, it will generate a URL with that same path."]})]})}function l(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>r});var s=n(7294);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);